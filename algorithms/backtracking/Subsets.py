# Given a set of distinct integers, S, return all possible subsets.
# 
# Note:
# Elements in a subset must be in non-descending order.
# The solution set must not contain duplicate subsets.
# For example,
# If S = [1,2,3], a solution is:
# 
# [
#   [3],
#   [1],
#   [2],
#   [1,2,3],
#   [1,3],
#   [2,3],
#   [1,2],
#   []
# ]
# 
# Idea2 :  
# Use dynamic programming . Let W(i) indicates the set of subsets of array [1, 2, ... , i]. Then, 
# W(i+1) = W(i) + { s+A[i+1] | s belongs to W(i) }. It means we can get W(i+1) from W(i).
# 
# Let's see an example {1, 2, 3}:
# 
# {}  {1}     {1, 2}  {1, 2, 3}
# []  [1]     [2]     [3]
#             [1, 2]  [1, 3]
#                     [2, 3]
#                     [1, 2, 3]
# 
# e.g. {1, 2, 3} = {for each previous results + 3} 
# 
# From the form above we can see, for each element in the array it would double the size of the set.
# Actually, for each element the incremental is generated by appending the element to the end of each arraylist in the set. 
# For example, for the element 2, it generated two more lists: [2] which comes from [] + 2, and [1, 2] which comes from [1] + 2.
# 
# O(2^n) ,Each time it would double the size of set

class SubSets:
    # @param S, a list of integer
    # @return a list of lists of integer
    def subsets(self, S): 
        result = [[]]
        S.sort()
        self.dfs(S, 0, result, [])
        return result

    def dfs(self, S, position, result, tmp):
        for i in xrange(position,len(S)):
            tmp.append(S[i])
            print i,tmp
            self.dfs(S, i+1, result, tmp)
            result.append(tmp[:])
            tmp.remove(S[i])

class SubSetsDP:
    # @param S, a list of integer
    # @return a list of lists of integer
    def subsets(self, S):
        S.sort()
        result = [[]]
        for i in xrange(len(S)):
            for j in xrange(len(result)):
                copy = result[j][:]
                copy.append(S[i])
                result.append(copy)
        return result

print SubSets().subsets([1,3,4,2])
